<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Multiplayer Grid Shooter</title>
    <style>
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f5f5f5;
            font-family: sans-serif;
        }

        #wrapper {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            position: relative;
        }

        #topRow {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        #joinForm {
            display: flex;
            gap: 6px;
            align-items: center;
            font-size: 14px;
        }

        #joinForm input {
            padding: 4px 6px;
            font-size: 13px;
        }

        #joinForm button {
            padding: 4px 10px;
            font-size: 13px;
            border: none;
            border-radius: 4px;
            background: #1e90ff;
            color: #fff;
            cursor: pointer;
        }

        #joinForm button:hover {
            opacity: 0.9;
        }

        #roomsContainer {
            font-size: 12px;
            color: #333;
            min-width: 160px;
        }

        #roomsTitle {
            font-weight: bold;
            margin-bottom: 4px;
        }

        #roomsList {
            border: 1px solid #ccc;
            background: #fff;
            padding: 4px;
            max-height: 140px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #roomsList button {
            width: 100%;
            padding: 2px 4px;
            font-size: 11px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background: #f7f7f7;
            text-align: left;
            cursor: pointer;
        }

        #roomsList button:hover {
            background: #e8f2ff;
        }

        #roomLabel {
            font-size: 13px;
            color: #555;
            min-height: 16px;
        }

        #controlsRow {
            display: flex;
            gap: 8px;
            align-items: center;
            width: 1200px;
            justify-content: space-between;
        }

        #startButton {
            padding: 3px 10px;
            font-size: 11px;
            border: none;
            border-radius: 4px;
            background: #27ae60;
            color: #fff;
            cursor: pointer;
            display: none;
        }

        #startButton:hover {
            opacity: 0.9;
        }

        canvas {
            border: 1px solid #999;
            background: #ffffff;
            display: none;
        }

        #cooldownWrapper {
            width: 1200px;
            height: 12px;
            font-size: 9px;
            color: #555;
            display: none;
            align-items: center;
            gap: 4px;
        }

        #cooldownBarBg {
            position: relative;
            flex: 1;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            overflow: hidden;
        }

        #cooldownBarBg::before,
        #cooldownBarBg::after {
            content: "";
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(0, 0, 0, 0.18);
            pointer-events: none;
        }

        #cooldownBarBg::before {
            left: calc(100% / 3);
        }

        #cooldownBarBg::after {
            left: calc(200% / 3);
        }

        #cooldownBarFill {
            height: 100%;
            width: 0;
            background: #1e90ff;
            border-radius: 3px;
            transition: width 0.06s linear;
        }

        #scoreboard {
            font-size: 11px;
            color: #333;
            min-height: 14px;
        }

        #statusMessage {
            font-size: 11px;
            color: #666;
            min-height: 14px;
        }

        #info {
            font-size: 11px;
            color: #333;
            max-width: 1200px;
            text-align: center;
        }

        #announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 8px 16px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 28px;
            font-weight: 700;
            color: #222;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 999;
            min-width: 260px;
        }

        #announcement.visible {
            opacity: 1;
        }
    </style>
</head>

<body>
    <div id="wrapper">
        <div id="topRow">
            <form id="joinForm">
                <span>Room:</span>
                <input id="roomInput" placeholder="e.g. arena-1" />
                <span>Name:</span>
                <input id="nameInput" placeholder="Your name" />
                <button type="submit">Join</button>
            </form>

            <div id="roomsContainer">
                <div id="roomsTitle">Active Rooms</div>
                <div id="roomsList">
                    <div>Loading...</div>
                </div>
            </div>
        </div>

        <div id="roomLabel"></div>

        <div id="controlsRow">
            <div id="statusMessage"></div>
            <button id="startButton">Start Round</button>
        </div>

        <!-- 40 x 18 tiles, 30px each -->
        <canvas id="game" width="1200" height="540"></canvas>

        <div id="cooldownWrapper">
            <span>Bullets:</span>
            <div id="cooldownBarBg">
                <div id="cooldownBarFill"></div>
            </div>
            <span id="cooldownText"></span>
        </div>

        <div id="scoreboard"></div>

        <div id="info">
            Create or join a room. First player becomes host. Host starts rounds (≥2 players).<br />
            Last player standing gets +1 point. Arrows: move. Space: shoot.<br />
            Terrain: black walls (solid), black+gold walls (reflect bullets), pixel-hole pits (instant death), black
            star spikes (-1 HP), green cacti that split a bullet once.
        </div>

        <div id="announcement"></div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

        let GRID_W = 40;
        let GRID_H = 18;
        let TILE_SIZE = canvas.width / GRID_W; // 30px
        const MOVE_DURATION = 80;
        const MAX_BULLETS = 3;
        const BULLET_RELOAD_MS = 1000;
        let JUMP_HEIGHT = TILE_SIZE * 0.35;

        const players = {};
        const anims = {};
        const projectiles = {};
        const impactEffects = [];

        let walls = [];
        let reflectWalls = [];
        let holes = [];
        let spikes = [];
        let cacti = [];

        let socket = null;
        let joined = false;
        let yourId = null;
        let hostId = null;
        let gameState = "waiting";

        const joinForm = document.getElementById("joinForm");
        const roomInput = document.getElementById("roomInput");
        const nameInput = document.getElementById("nameInput");
        const roomsContainer = document.getElementById("roomsContainer");
        const roomsListDiv = document.getElementById("roomsList");
        const roomLabel = document.getElementById("roomLabel");
        const scoreboardDiv = document.getElementById("scoreboard");
        const statusMessageDiv = document.getElementById("statusMessage");
        const announcementDiv = document.getElementById("announcement");
        const infoDiv = document.getElementById("info");
        const startButton = document.getElementById("startButton");
        const cooldownWrapper = document.getElementById("cooldownWrapper");
        const cooldownBarFill = document.getElementById("cooldownBarFill");
        const cooldownText = document.getElementById("cooldownText");

        let countdownStartTime = null;
        let countdownDuration = 0;

        // --- SOCKET INIT ---

        socket = io();

        socket.on("roomsUpdate", rooms => {
            if (!joined) renderRoomsList(rooms);
        });

        joinForm.addEventListener("submit", e => {
            e.preventDefault();
            if (joined) return;
            const roomId = roomInput.value.trim() || "lobby";
            const name = nameInput.value.trim() || "";
            socket.emit("joinRoom", {
                roomId,
                name
            });
        });

        function renderRoomsList(rooms) {
            roomsListDiv.innerHTML = "";
            if (!rooms || rooms.length === 0) {
                roomsListDiv.innerHTML = "<div>No active rooms yet</div>";
                return;
            }
            rooms
                .sort((a, b) => a.roomId.localeCompare(b.roomId))
                .forEach(r => {
                    const btn = document.createElement("button");
                    btn.textContent = `${r.roomId} (${r.count})`;
                    btn.onclick = () => {
                        if (joined) return;
                        const name = nameInput.value.trim() || "";
                        socket.emit("joinRoom", {
                            roomId: r.roomId,
                            name
                        });
                    };
                    roomsListDiv.appendChild(btn);
                });
        }

        socket.on("currentState", data => {
            joined = true;
            yourId = data.yourId;
            hostId = data.hostId || null;

            GRID_W = data.gridWidth || GRID_W;
            GRID_H = data.gridHeight || GRID_H;
            TILE_SIZE = canvas.width / GRID_W;
            JUMP_HEIGHT = TILE_SIZE * 0.35;

            walls = data.walls || [];
            reflectWalls = data.reflectWalls || [];
            holes = data.holes || [];
            spikes = data.spikes || [];
            cacti = (data.cacti || []).map(c => ({
                ...c
            }));

            for (const id in players) delete players[id];
            Object.assign(players, data.players || {});
            clearProjectilesLocal();

            gameState = data.state || "waiting";
            countdownStartTime = null;
            countdownDuration = 0;

            roomLabel.textContent = `Room: ${data.roomId}`;

            canvas.style.display = "block";
            cooldownWrapper.style.display = "flex";

            // Hide lobby UI inside room
            joinForm.style.display = "none";
            roomsContainer.style.display = "none";
            infoDiv.style.display = "none";

            renderScoreboard();
            renderStatus();
            updateAnnouncementInstant();
            renderHostControls();
        });

        socket.on("playerJoined", ({
            id,
            player
        }) => {
            players[id] = player;
            renderScoreboard();
            renderHostControls();
        });

        socket.on("playerLeft", ({
            id
        }) => {
            delete players[id];
            delete anims[id];
            renderScoreboard();
            renderHostControls();
        });

        socket.on("hostUpdate", ({
            hostId: newHost
        }) => {
            hostId = newHost || null;
            renderHostControls();
        });

        socket.on("playerMove", ({
            id,
            fromX,
            fromY,
            toX,
            toY,
            facing
        }) => {
            if (!players[id]) {
                players[id] = {
                    x: toX,
                    y: toY,
                    color: "#000",
                    name: `P-${id.slice(0, 4)}`,
                    hp: 5,
                    facing: facing || "down",
                    score: 0,
                    bulletsLoaded: 0
                };
            }
            if (facing) players[id].facing = facing;

            const existing = anims[id];
            if (existing && existing.active) {
                players[id].x = existing.toX;
                players[id].y = existing.toY;
                existing.active = false;
            }

            if (fromX === toX && fromY === toY) {
                anims[id] = {
                    fromX,
                    fromY,
                    toX,
                    toY,
                    startTime: performance.now(),
                    active: false
                };
                return;
            }

            anims[id] = {
                fromX,
                fromY,
                toX,
                toY,
                startTime: performance.now(),
                active: true
            };
        });

        socket.on("healthUpdate", ({
            hits
        }) => {
            hits.forEach(({
                id,
                hp
            }) => {
                if (players[id]) players[id].hp = hp;
            });
        });

        socket.on("ammoUpdate", ({
            id,
            bullets,
            lastReloadTime
        }) => {
            if (!players[id]) return;
            players[id].bulletsLoaded = bullets;
            if (typeof lastReloadTime === "number") {
                players[id].lastReloadTime = lastReloadTime;
            }
        });

        socket.on("ammoBulkUpdate", ({
            updates
        }) => {
            if (!updates) return;
            updates.forEach(({
                id,
                bullets,
                lastReloadTime
            }) => {
                if (!players[id]) return;
                players[id].bulletsLoaded = bullets;
                if (typeof lastReloadTime === "number") {
                    players[id].lastReloadTime = lastReloadTime;
                }
            });
        });

        socket.on("projectileSpawn", ({
            id,
            x,
            y,
            dx,
            dy
        }) => {
            projectiles[id] = {
                x,
                y,
                dx,
                dy
            };
        });

        socket.on("projectileUpdate", ({
            id,
            x,
            y,
            dx,
            dy
        }) => {
            if (!projectiles[id]) return;
            if (typeof x === "number") projectiles[id].x = x;
            if (typeof y === "number") projectiles[id].y = y;
            if (typeof dx === "number") projectiles[id].dx = dx;
            if (typeof dy === "number") projectiles[id].dy = dy;
        });

        socket.on("projectileDestroy", ({
            id,
            x,
            y
        }) => {
            const p = projectiles[id];
            if (p) {
                const px = typeof x === "number" ? x : p.x;
                const py = typeof y === "number" ? y : p.y;
                impactEffects.push({
                    x: px,
                    y: py,
                    startTime: performance.now(),
                    duration: 120
                });
                delete projectiles[id];
            }
        });

        socket.on("clearProjectiles", () => {
            clearProjectilesLocal();
        });

        socket.on("cactusUsed", ({
            x,
            y
        }) => {
            const c = cacti.find(c => c.x === x && c.y === y);
            if (c) c.used = true;
        });

        socket.on("roundState", ({
            state,
            countdown,
            players: serverPlayers,
            hostId: newHost,
            cacti: serverCacti
        }) => {
            gameState = state;
            if (typeof newHost !== "undefined") hostId = newHost;
            if (serverPlayers) {
                for (const id in players) delete players[id];
                Object.assign(players, serverPlayers);
            }
            if (serverCacti) {
                cacti = serverCacti.map(c => ({
                    ...c
                }));
            }

            clearProjectilesLocal();

            if (state === "waiting") {
                countdownStartTime = null;
                countdownDuration = 0;
            } else if (state === "countdown") {
                countdownDuration = countdown || 3000;
                countdownStartTime = performance.now();
            } else if (state === "playing") {
                countdownStartTime = null;
                countdownDuration = 0;
            }

            renderScoreboard();
            renderStatus();
            updateAnnouncementInstant();
            renderHostControls();
        });

        socket.on("roundOver", ({
            winnerId,
            scores,
            hostId: newHost,
            cacti: serverCacti
        }) => {
            gameState = "round_over";
            if (typeof newHost !== "undefined") hostId = newHost;
            if (serverCacti) {
                cacti = serverCacti.map(c => ({
                    ...c
                }));
            }

            clearProjectilesLocal();

            if (scores) {
                Object.entries(scores).forEach(([id, score]) => {
                    if (!players[id]) players[id] = {};
                    players[id].score = score;
                });
            }
            renderScoreboard();

            let msg;
            if (winnerId && players[winnerId]) {
                const name = players[winnerId].name || "Player";
                msg = `${name} wins this round!`;
            } else {
                msg = "Round over!";
            }

            announcementDiv.textContent = msg;
            announcementDiv.classList.add("visible");
            statusMessageDiv.textContent = `${msg} Host can start the next round.`;

            renderHostControls();
        });

        // --- INPUT ---

        window.addEventListener("keydown", e => {
            if (!joined || !socket) return;
            if (gameState !== "playing") return;

            const me = players[yourId];
            if (!me || me.hp <= 0) return;

            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
                e.preventDefault();
                const dir =
                    e.key === "ArrowUp" ? "up" :
                    e.key === "ArrowDown" ? "down" :
                    e.key === "ArrowLeft" ? "left" : "right";
                socket.emit("move", {
                    direction: dir
                });
                return;
            }

            if (e.code === "Space") {
                e.preventDefault();
                const bullets = me.bulletsLoaded ?? 0;
                if (bullets <= 0) return;
                socket.emit("shoot");
            }
        });

        startButton.addEventListener("click", () => {
            if (!socket) return;
            socket.emit("startRound");
        });

        // --- HELPERS ---

        function clearProjectilesLocal() {
            for (const id in projectiles) delete projectiles[id];
            impactEffects.length = 0;
        }

        function renderScoreboard() {
            const ids = Object.keys(players);
            if (!ids.length) {
                scoreboardDiv.textContent = "";
                return;
            }
            const parts = ids.map(id => {
                const p = players[id];
                if (!p) return "";
                const name = p.name || id.slice(0, 4);
                const score = p.score || 0;
                return `${name}: ${score}`;
            }).filter(Boolean);
            scoreboardDiv.textContent = parts.length ?
                "Score • " + parts.join(" | ") :
                "";
        }

        function renderStatus() {
            if (gameState === "waiting") {
                statusMessageDiv.textContent = "Waiting. Host can start when ready (≥2 players).";
            } else if (gameState === "countdown") {
                statusMessageDiv.textContent = "Round starting...";
            } else if (gameState === "playing") {
                statusMessageDiv.textContent = "Fight!";
            }
        }

        function renderHostControls() {
            if (!joined) {
                startButton.style.display = "none";
                return;
            }
            const isHost = yourId && hostId && yourId === hostId;
            if (!isHost) {
                startButton.style.display = "none";
                return;
            }
            const playersCount = Object.keys(players).length;
            if ((gameState === "waiting" || gameState === "round_over") && playersCount >= 2) {
                startButton.style.display = "inline-block";
            } else {
                startButton.style.display = "none";
            }
        }

        function updateAnnouncementInstant() {
            if (gameState === "waiting") {
                announcementDiv.textContent = "Waiting for host to start (≥2 players)...";
                announcementDiv.classList.add("visible");
            } else if (gameState === "playing") {
                announcementDiv.textContent = "";
                announcementDiv.classList.remove("visible");
            }
        }

        function updateAnnouncementDuringCountdown(now) {
            if (gameState !== "countdown" || countdownStartTime === null) return;
            const elapsed = now - countdownStartTime;
            let remaining = countdownDuration - elapsed;
            if (remaining < 0) remaining = 0;
            const seconds = Math.max(1, Math.ceil(remaining / 1000));
            announcementDiv.textContent = `Round starts in ${seconds}`;
            announcementDiv.classList.add("visible");
        }

        function getBulletFillRatio(now) {
            const me = players[yourId];
            if (!me) return 0;
            const base = Math.max(0, Math.min(MAX_BULLETS, me.bulletsLoaded || 0));
            let ratio = base / MAX_BULLETS;

            if (
                base < MAX_BULLETS &&
                typeof me.lastReloadTime === "number" &&
                (gameState === "playing" || gameState === "countdown")
            ) {
                const elapsed = now - me.lastReloadTime;
                const extra = Math.max(0, Math.min(1, elapsed / BULLET_RELOAD_MS));
                ratio += extra / MAX_BULLETS;
            }

            return Math.max(0, Math.min(1, ratio));
        }

        function updateBulletUI(now = performance.now()) {
            if (!joined) return;
            const me = players[yourId];
            const bullets = me && typeof me.bulletsLoaded === "number" ?
                Math.max(0, Math.min(MAX_BULLETS, me.bulletsLoaded)) :
                0;

            const ratio = getBulletFillRatio(now);
            cooldownBarFill.style.width = `${ratio * 100}%`;
            cooldownText.textContent = `${bullets}/${MAX_BULLETS}`;
        }

        // --- TERRAIN RENDERING ---

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#e0e0e0";

            for (let x = 0; x <= GRID_W; x++) {
                const px = x * TILE_SIZE;
                ctx.beginPath();
                ctx.moveTo(px, 0);
                ctx.lineTo(px, canvas.height);
                ctx.stroke();
            }

            for (let y = 0; y <= GRID_H; y++) {
                const py = y * TILE_SIZE;
                ctx.beginPath();
                ctx.moveTo(0, py);
                ctx.lineTo(canvas.width, py);
                ctx.stroke();
            }
        }

        function drawTerrain() {
            // Walls: solid black
            ctx.fillStyle = "#000";
            walls.forEach(w => {
                ctx.fillRect(w.x * TILE_SIZE, w.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            });

            // Reflecting walls: black with thick bright gold border
            reflectWalls.forEach(w => {
                const x = w.x * TILE_SIZE;
                const y = w.y * TILE_SIZE;
                ctx.fillStyle = "#000";
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                ctx.lineWidth = 4;
                ctx.strokeStyle = "#ffd700";
                ctx.strokeRect(x + 1.5, y + 1.5, TILE_SIZE - 3, TILE_SIZE - 3);
            });

            // Spikes: black X
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3;
            spikes.forEach(s => {
                const x = s.x * TILE_SIZE;
                const y = s.y * TILE_SIZE;
                ctx.beginPath();
                ctx.moveTo(x + TILE_SIZE * 0.2, y + TILE_SIZE * 0.2);
                ctx.lineTo(x + TILE_SIZE * 0.8, y + TILE_SIZE * 0.8);
                ctx.moveTo(x + TILE_SIZE * 0.8, y + TILE_SIZE * 0.2);
                ctx.lineTo(x + TILE_SIZE * 0.2, y + TILE_SIZE * 0.8);
                ctx.stroke();
            });

            // Cacti: almost full tile, with bullet pods sticking out a bit
            cacti.forEach(c => {
                const x = c.x * TILE_SIZE;
                const y = c.y * TILE_SIZE;

                // slightly inset body so pods can pop out
                const pad = TILE_SIZE * 0.14;
                const bodyX = x + pad;
                const bodyY = y + pad;
                const bodyW = TILE_SIZE - pad * 2;
                const bodyH = TILE_SIZE - pad * 2;

                ctx.fillStyle = "#27ae60";
                ctx.fillRect(bodyX, bodyY, bodyW, bodyH);

                if (!c.used) {
                    ctx.fillStyle = "#000";
                    const bLen = TILE_SIZE * 0.46;
                    const bThick = TILE_SIZE * 0.12;

                    // Up (extends slightly above body)
                    ctx.fillRect(
                        x + TILE_SIZE / 2 - bThick / 2,
                        bodyY - bLen * 0.35,
                        bThick,
                        bLen
                    );

                    // Down
                    ctx.fillRect(
                        x + TILE_SIZE / 2 - bThick / 2,
                        bodyY + bodyH - bLen * 0.65,
                        bThick,
                        bLen
                    );

                    // Left
                    ctx.fillRect(
                        bodyX - bLen * 0.35,
                        y + TILE_SIZE / 2 - bThick / 2,
                        bLen,
                        bThick
                    );

                    // Right
                    ctx.fillRect(
                        bodyX + bodyW - bLen * 0.65,
                        y + TILE_SIZE / 2 - bThick / 2,
                        bLen,
                        bThick
                    );
                }
            });
        }

        // --- PLAYER DRAW ---

        function drawTrianglePlayer(id, gridX, gridY, jumpOffset = 0) {
            const p = players[id];
            if (!p) return;

            const padding = TILE_SIZE * 0.12;
            const baseX = gridX * TILE_SIZE;
            const baseY = gridY * TILE_SIZE + jumpOffset;

            // Highlight your tile
            if (id === yourId) {
                ctx.fillStyle = "rgba(255, 255, 0, 0.16)";
                ctx.fillRect(baseX, gridY * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }

            const px = baseX + padding;
            const py = baseY + padding;
            const size = TILE_SIZE - padding * 2;
            const cx = px + size / 2;
            const cy = py + size / 2;

            let tip, back1, back2;
            switch (p.facing || "down") {
                case "up":
                    tip = {
                        x: cx,
                        y: py
                    };
                    back1 = {
                        x: px,
                        y: py + size
                    };
                    back2 = {
                        x: px + size,
                        y: py + size
                    };
                    break;
                case "down":
                    tip = {
                        x: cx,
                        y: py + size
                    };
                    back1 = {
                        x: px,
                        y: py
                    };
                    back2 = {
                        x: px + size,
                        y: py
                    };
                    break;
                case "left":
                    tip = {
                        x: px,
                        y: cy
                    };
                    back1 = {
                        x: px + size,
                        y: py
                    };
                    back2 = {
                        x: px + size,
                        y: py + size
                    };
                    break;
                case "right":
                default:
                    tip = {
                        x: px + size,
                        y: cy
                    };
                    back1 = {
                        x: px,
                        y: py
                    };
                    back2 = {
                        x: px,
                        y: py + size
                    };
                    break;
            }

            // Soft drop shadow (simple triangle)
            ctx.save();
            ctx.fillStyle = "rgba(0,0,0,0.18)";
            ctx.beginPath();
            ctx.moveTo(tip.x + 2, tip.y + 2);
            ctx.lineTo(back1.x + 2, back1.y + 2);
            ctx.lineTo(back2.x + 2, back2.y + 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            const radius = TILE_SIZE * 0.18;

            // Rounded triangle body: sharp tip, rounded back corners
            ctx.beginPath();
            ctx.moveTo(tip.x, tip.y);
            ctx.lineTo(back1.x, back1.y);
            ctx.arcTo(back1.x, back1.y, back2.x, back2.y, radius);
            ctx.lineTo(back2.x, back2.y);
            ctx.arcTo(back2.x, back2.y, tip.x, tip.y, radius);
            ctx.lineTo(tip.x, tip.y);
            ctx.closePath();

            const baseColor = p.color || "#1e90ff";
            ctx.fillStyle = p.hp > 0 ? baseColor : "#7f8c8d";
            ctx.fill();

            // Extra outline for your player
            if (id === yourId) {
                ctx.lineWidth = 3;
                ctx.strokeStyle = "#000";
                ctx.stroke();
            }

            // Segmented HP bar (5)
            const maxHp = 5;
            const hp = Math.max(0, Math.min(maxHp, p.hp || 0));
            const segments = 5;
            const gap = 1;
            const barWidth = size;
            const barHeight = 3;
            const barX = px;
            const barY = py + size + 2;
            const segWidth = (barWidth - gap * (segments - 1)) / segments;

            for (let i = 0; i < segments; i++) {
                const sx = barX + i * (segWidth + gap);
                ctx.fillStyle = "#ccc";
                ctx.fillRect(sx, barY, segWidth, barHeight);
                if (i < hp) {
                    ctx.fillStyle = "#27ae60";
                    ctx.fillRect(sx, barY, segWidth, barHeight);
                }
            }

            // Name
            if (p.name) {
                ctx.font = "10px sans-serif";
                ctx.fillStyle = "#333";
                ctx.textAlign = "center";
                ctx.fillText(p.name, cx, py - 4);
            }
        }

        // --- PROJECTILES DRAW ---

        function drawProjectiles(now) {
            // Group by tile+direction for stacks
            const groups = {};
            for (const id in projectiles) {
                const p = projectiles[id];
                const key = `${p.x},${p.y},${p.dx},${p.dy}`;
                if (!groups[key]) {
                    groups[key] = {
                        x: p.x,
                        y: p.y,
                        dx: p.dx,
                        dy: p.dy,
                        count: 0
                    };
                }
                groups[key].count++;
            }

            ctx.save();
            ctx.fillStyle = "#000";
            Object.values(groups).forEach(g => {
                const {
                    x,
                    y,
                    dx,
                    dy,
                    count
                } = g;
                const centerX = x * TILE_SIZE + TILE_SIZE / 2;
                const centerY = y * TILE_SIZE + TILE_SIZE / 2;
                const n = Math.max(1, count);

                if (dx !== 0) {
                    const w = TILE_SIZE * 0.6;
                    const h = TILE_SIZE * 0.14;
                    const gap = TILE_SIZE * 0.05;
                    const totalH = n * h + (n - 1) * gap;
                    let sy = centerY - totalH / 2;
                    for (let i = 0; i < n; i++) {
                        ctx.fillRect(centerX - w / 2, sy, w, h);
                        sy += h + gap;
                    }
                } else if (dy !== 0) {
                    const w = TILE_SIZE * 0.14;
                    const h = TILE_SIZE * 0.6;
                    const gap = TILE_SIZE * 0.05;
                    const totalW = n * w + (n - 1) * gap;
                    let sx = centerX - totalW / 2;
                    for (let i = 0; i < n; i++) {
                        ctx.fillRect(sx, centerY - h / 2, w, h);
                        sx += w + gap;
                    }
                }
            });
            ctx.restore();

            // Impact flashes
            const keep = [];
            impactEffects.forEach(effect => {
                const t = now - effect.startTime;
                if (t < 0 || t > effect.duration) return;
                const alpha = 1 - t / effect.duration;
                const cx = effect.x * TILE_SIZE + TILE_SIZE / 2;
                const cy = effect.y * TILE_SIZE + TILE_SIZE / 2;
                const size = TILE_SIZE * 0.4;

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = "#e74c3c";
                ctx.fillRect(cx - size / 2, cy - size / 2, size, size);
                ctx.restore();

                keep.push(effect);
            });
            impactEffects.length = 0;
            impactEffects.push(...keep);
        }

        // --- MAIN LOOP ---

        function gameLoop(timestamp) {
            if (!joined) {
                requestAnimationFrame(gameLoop);
                return;
            }

            const now = timestamp || performance.now();

            drawGrid();
            drawTerrain();

            for (const id in players) {
                const p = players[id];
                const anim = anims[id];

                if (anim && anim.active) {
                    const elapsed = now - anim.startTime;
                    let t = elapsed / MOVE_DURATION;
                    if (t >= 1) {
                        t = 1;
                        anim.active = false;
                        p.x = anim.toX;
                        p.y = anim.toY;
                        drawTrianglePlayer(id, p.x, p.y, 0);
                    } else {
                        const gx = anim.fromX + (anim.toX - anim.fromX) * t;
                        const gy = anim.fromY + (anim.toY - anim.fromY) * t;
                        const dx = anim.toX - anim.fromX;
                        const dy = anim.toY - anim.fromY;
                        let jumpOffset = 0;
                        if (dy !== 0 && dx === 0) {
                            jumpOffset = -4 * JUMP_HEIGHT * t * (1 - t);
                        }
                        drawTrianglePlayer(id, gx, gy, jumpOffset);
                    }
                } else {
                    drawTrianglePlayer(id, p.x, p.y, 0);
                }
            }

            drawProjectiles(now);
            updateBulletUI(now);

            if (gameState === "countdown") {
                updateAnnouncementDuringCountdown(now);
            } else if (gameState === "playing") {
                if (announcementDiv.textContent.startsWith("Round starts in")) {
                    announcementDiv.textContent = "";
                    announcementDiv.classList.remove("visible");
                }
            } else if (gameState === "waiting") {
                announcementDiv.textContent = "Waiting for host to start (≥2 players)...";
                announcementDiv.classList.add("visible");
            }

            renderHostControls();
            requestAnimationFrame(gameLoop);
        }

        requestAnimationFrame(gameLoop);
    </script>
</body>

</html>