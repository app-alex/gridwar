<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Multiplayer Grid Shooter</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <style>
        :root {
            --accent: #1e90ff;
            --accent-soft: rgba(30, 144, 255, 0.15);
            --bg-gradient: linear-gradient(135deg, #f5f7fb, #e6f0ff);
            --card-bg: rgba(255, 255, 255, 0.98);
            --border-soft: rgba(0, 0, 0, 0.08);
            --radius-lg: 14px;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background: var(--bg-gradient);
            font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            touch-action: none;
            overflow-y: auto;
            color: #222;
        }

        #wrapper {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            position: relative;
            width: 100%;
            max-width: 1200px;
            padding: 8px 10px 8px;
            box-sizing: border-box;
        }

        #appTitle {
            font-size: 22px;
            font-weight: 700;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: #222;
            text-align: center;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #appTitle span.logo-dot {
            width: 9px;
            height: 9px;
            border-radius: 50%;
            background: var(--accent);
            display: inline-block;
        }

        #appSubtitle {
            font-size: 11px;
            color: #666;
            text-align: center;
            margin-bottom: 6px;
        }

        #topRow {
            display: flex;
            gap: 14px;
            align-items: stretch;
            width: 100%;
            flex-wrap: wrap;
        }

        #joinCard {
            flex: 1.4;
            min-width: 260px;
            padding: 10px 12px;
            border-radius: var(--radius-lg);
            background: var(--card-bg);
            box-shadow: 0 6px 16px rgba(15, 23, 42, 0.09);
            border: 1px solid var(--border-soft);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        #joinTitle {
            font-size: 13px;
            font-weight: 600;
            color: #222;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #joinTitle span.pill {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 999px;
            background: var(--accent-soft);
            color: var(--accent);
        }

        #joinForm {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 2px;
            align-items: center;
        }

        #joinForm label {
            font-size: 10px;
            color: #555;
        }

        #joinForm input {
            padding: 5px 7px;
            font-size: 11px;
            border-radius: 6px;
            border: 1px solid #d0d7e2;
            outline: none;
            flex: 1;
            min-width: 90px;
            background: #fafbff;
        }

        #joinForm input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px var(--accent-soft);
        }

        #joinForm button {
            padding: 6px 14px;
            font-size: 11px;
            border: none;
            border-radius: 999px;
            background: var(--accent);
            color: #fff;
            cursor: pointer;
            white-space: nowrap;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 3px 8px rgba(30, 144, 255, 0.35);
        }

        #joinForm button:hover {
            opacity: 0.96;
            transform: translateY(-0.5px);
        }

        #joinHint {
            font-size: 9px;
            color: #888;
        }

        #roomsContainer {
            flex: 1;
            min-width: 200px;
            padding: 10px 10px 8px;
            border-radius: var(--radius-lg);
            background: var(--card-bg);
            box-shadow: 0 6px 16px rgba(15, 23, 42, 0.05);
            border: 1px solid var(--border-soft);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #roomsHeaderRow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 6px;
        }

        #roomsTitle {
            font-weight: 600;
            font-size: 12px;
            color: #222;
        }

        #roomsHint {
            font-size: 9px;
            color: #777;
        }

        #roomsList {
            margin-top: 2px;
            border-radius: 8px;
            border: 1px solid #e0e4f0;
            background: #fafbff;
            padding: 4px;
            max-height: 120px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 10px;
        }

        #roomsList button {
            width: 100%;
            padding: 5px 7px;
            font-size: 10px;
            border: none;
            border-radius: 6px;
            background: #ffffff;
            text-align: left;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 1px 3px rgba(15, 23, 42, 0.06);
            border: 1px solid rgba(148, 163, 253, 0.25);
        }

        #roomsList button span.name {
            font-weight: 500;
            color: #333;
        }

        #roomsList button span.count {
            font-size: 9px;
            color: #6b7280;
        }

        #roomsList button:hover {
            background: #eff6ff;
        }

        #roomLabel {
            font-size: 12px;
            color: #444;
            min-height: 16px;
            width: 100%;
            margin-top: 2px;
        }

        #controlsRow {
            display: flex;
            gap: 8px;
            align-items: center;
            width: 100%;
            justify-content: space-between;
            box-sizing: border-box;
        }

        #startButton {
            padding: 4px 12px;
            font-size: 10px;
            border: none;
            border-radius: 999px;
            background: #27ae60;
            color: #fff;
            cursor: pointer;
            display: none;
            white-space: nowrap;
            box-shadow: 0 3px 8px rgba(39, 174, 96, 0.3);
        }

        #startButton:hover {
            opacity: 0.97;
            transform: translateY(-0.5px);
        }

        #statusMessage {
            font-size: 10px;
            color: #666;
            min-height: 14px;
            flex: 1;
        }

        canvas {
            border: 1px solid #cbd5e1;
            background: #ffffff;
            display: none;
            width: 100%;
            height: auto;
            touch-action: none;
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.14);
        }

        #cooldownWrapper {
            width: 100%;
            height: 12px;
            font-size: 9px;
            color: #556;
            display: none;
            align-items: center;
            gap: 4px;
            box-sizing: border-box;
        }

        #cooldownBarBg {
            position: relative;
            flex: 1;
            height: 6px;
            background: #e5e7eb;
            border-radius: 999px;
            overflow: hidden;
        }

        #cooldownBarBg::before,
        #cooldownBarBg::after {
            content: "";
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(0, 0, 0, 0.18);
            pointer-events: none;
        }

        #cooldownBarBg::before {
            left: calc(100% / 3);
        }

        #cooldownBarBg::after {
            left: calc(200% / 3);
        }

        #cooldownBarFill {
            height: 100%;
            width: 0;
            background: var(--accent);
            border-radius: 999px;
            transition: width 0.06s linear;
        }

        #cooldownText {
            min-width: 40px;
            text-align: right;
        }

        #scoreboard {
            font-size: 11px;
            color: #333;
            min-height: 14px;
            width: 100%;
        }

        #info {
            font-size: 10px;
            color: #555;
            max-width: 100%;
            text-align: center;
        }

        #touchHint {
            display: none;
            font-size: 9px;
            color: #555;
            text-align: center;
            max-width: 100%;
        }

        #announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 8px 16px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.96);
            font-size: 20px;
            font-weight: 700;
            color: #111827;
            text-align: center;
            box-shadow: 0 8px 26px rgba(15, 23, 42, 0.28);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 999;
            min-width: 220px;
        }

        #announcement.visible {
            opacity: 1;
        }

        #touchFeedback {
            position: fixed;
            background: rgba(30, 144, 255, 0.12);
            border: 1px solid rgba(30, 144, 255, 0.35);
            border-radius: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease-out;
            z-index: 900;
        }

        @media (max-height: 600px) {
            #wrapper {
                gap: 4px;
                padding-top: 4px;
                padding-bottom: 4px;
            }

            #appTitle {
                font-size: 18px;
            }

            #appSubtitle {
                font-size: 9px;
            }

            #joinForm input,
            #joinForm button {
                font-size: 10px;
            }

            #roomsList {
                max-height: 90px;
            }

            #statusMessage,
            #scoreboard,
            #info,
            #touchHint {
                font-size: 8.5px;
            }

            #announcement {
                font-size: 17px;
                padding: 6px 10px;
            }
        }

        @media (max-width: 768px) {
            #topRow {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>
    <div id="wrapper">
        <div id="appTitle">
            <span class="logo-dot"></span>
            Online Grid Arena
        </div>
        <div id="appSubtitle">Join a room, outplay the others with clever movement and shots. Last triangle standing
            scores.</div>

        <div id="topRow">
            <div id="joinCard">
                <div id="joinTitle">
                    Join or create a room
                    <span class="pill">1. Choose room &amp; name</span>
                </div>
                <form id="joinForm">
                    <label for="roomInput">Room</label>
                    <input id="roomInput" placeholder="e.g. arena-1 (new or existing)" />
                    <label for="nameInput">Name</label>
                    <input id="nameInput" placeholder="Your name" />
                    <button type="submit">
                        <span>Enter Arena</span>
                        <span>↗</span>
                    </button>
                </form>
                <div id="joinHint">Rooms are created automatically if they don't exist yet.</div>
            </div>

            <div id="roomsContainer">
                <div id="roomsHeaderRow">
                    <div>
                        <div id="roomsTitle">Active Rooms</div>
                        <div id="roomsHint">Tap to quick-join someone already playing.</div>
                    </div>
                </div>
                <div id="roomsList">
                    <div>No active rooms yet. Create one on the left.</div>
                </div>
            </div>
        </div>

        <div id="roomLabel"></div>

        <div id="controlsRow">
            <div id="statusMessage"></div>
            <button id="startButton">Start Round</button>
        </div>

        <canvas id="game" width="1200" height="540"></canvas>

        <div id="cooldownWrapper">
            <span>Bullets:</span>
            <div id="cooldownBarBg">
                <div id="cooldownBarFill"></div>
            </div>
            <span id="cooldownText"></span>
        </div>

        <div id="scoreboard"></div>

        <div id="info">
            Desktop: arrows to move, Space to shoot. Host starts rounds (≥2 players). Last player standing gets 1
            point.<br />
            Terrain: black walls (solid), black+gold walls (reflect bullets), X spikes (-1 HP), green cactus that splits
            a bullet once, then becomes solid.
        </div>

        <div id="touchHint">
            Touch: top/bottom bands = up/down, side middle bands = left/right, center = shoot.
        </div>

        <div id="announcement"></div>
        <div id="touchFeedback"></div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const wrapper = document.getElementById("wrapper");

        let GRID_W = 40;
        let GRID_H = 18;
        let TILE_SIZE = canvas.width / GRID_W;
        const MOVE_DURATION = 80;
        const MAX_BULLETS = 3;
        const BULLET_RELOAD_MS = 1000;
        let JUMP_HEIGHT = TILE_SIZE * 0.35;

        const players = {};
        const anims = {};
        const projectiles = {};
        const impactEffects = [];

        let walls = [];
        let reflectWalls = [];
        let spikes = [];
        let cacti = [];

        let socket = null;
        let joined = false;
        let yourId = null;
        let hostId = null;
        let gameState = "waiting";

        const joinCard = document.getElementById("joinCard");
        const joinForm = document.getElementById("joinForm");
        const roomInput = document.getElementById("roomInput");
        const nameInput = document.getElementById("nameInput");
        const roomsContainer = document.getElementById("roomsContainer");
        const roomsListDiv = document.getElementById("roomsList");
        const roomLabel = document.getElementById("roomLabel");
        const scoreboardDiv = document.getElementById("scoreboard");
        const statusMessageDiv = document.getElementById("statusMessage");
        const announcementDiv = document.getElementById("announcement");
        const infoDiv = document.getElementById("info");
        const startButton = document.getElementById("startButton");
        const cooldownWrapper = document.getElementById("cooldownWrapper");
        const cooldownBarFill = document.getElementById("cooldownBarFill");
        const cooldownText = document.getElementById("cooldownText");
        const touchHint = document.getElementById("touchHint");
        const touchFeedbackEl = document.getElementById("touchFeedback");

        let countdownStartTime = null;
        let countdownDuration = 0;
        let touchFeedbackTimeout = null;
        let hasRequestedFullscreen = false;

        const isTouchDevice =
            "ontouchstart" in window ||
            navigator.maxTouchPoints > 0 ||
            navigator.msMaxTouchPoints > 0;

        if (isTouchDevice) {
            touchHint.style.display = "block";
        }

        // --- Fullscreen helper (best-effort, only on user gesture) ---

        function tryEnterFullscreen() {
            if (hasRequestedFullscreen) return;
            if (!isTouchDevice) return; // mostly helps mobile

            const el = document.documentElement; // or wrapper
            if (el.requestFullscreen) {
                el.requestFullscreen().catch(() => {});
                hasRequestedFullscreen = true;
            } else if (el.webkitRequestFullscreen) {
                el.webkitRequestFullscreen();
                hasRequestedFullscreen = true;
            }
            // Note: Some mobile browsers may ignore this; that's fine.
        }

        // --- Touch feedback zones ---

        function showTouchFeedback(kind, dir, marginX, marginY) {
            if (!touchFeedbackEl) return;

            const vw = window.innerWidth;
            const vh = window.innerHeight;
            let left = 0,
                top = 0,
                width = 0,
                height = 0;
            let radius = 10;

            if (kind === "move") {
                if (dir === "up") {
                    left = 0;
                    top = 0;
                    width = vw;
                    height = marginY;
                    radius = 0;
                } else if (dir === "down") {
                    left = 0;
                    top = vh - marginY;
                    width = vw;
                    height = marginY;
                    radius = 0;
                } else if (dir === "left") {
                    left = 0;
                    top = marginY;
                    width = marginX;
                    height = vh - 2 * marginY;
                    radius = 0;
                } else if (dir === "right") {
                    left = vw - marginX;
                    top = marginY;
                    width = marginX;
                    height = vh - 2 * marginY;
                    radius = 0;
                }
            } else if (kind === "shoot") {
                left = marginX;
                top = marginY;
                width = vw - 2 * marginX;
                height = vh - 2 * marginY;
                radius = 16;
            }

            touchFeedbackEl.style.left = left + "px";
            touchFeedbackEl.style.top = top + "px";
            touchFeedbackEl.style.width = width + "px";
            touchFeedbackEl.style.height = height + "px";
            touchFeedbackEl.style.borderRadius = radius + "px";
            touchFeedbackEl.style.opacity = "1";

            if (touchFeedbackTimeout) clearTimeout(touchFeedbackTimeout);
            touchFeedbackTimeout = setTimeout(() => {
                touchFeedbackEl.style.opacity = "0";
            }, 120);
        }

        // --- Responsive canvas: clamp to viewport when in room ---

        function adjustCanvasSize() {
            if (!joined || canvas.style.display === "none") return;

            canvas.style.width = "100%";
            canvas.style.height = "auto";

            const viewportH = window.innerHeight;
            const wrapperRect = wrapper.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            const otherHeight = wrapperRect.height - canvasRect.height;

            const aspect = canvas.width / canvas.height;
            const wrapperWidth = wrapper.clientWidth;
            const maxTotal = viewportH - 2;
            let maxCanvasHeight = maxTotal - otherHeight;

            if (maxCanvasHeight <= 0) maxCanvasHeight = 60;

            if (canvasRect.height > maxCanvasHeight) {
                let newH = Math.max(60, maxCanvasHeight);
                let newW = newH * aspect;
                if (newW > wrapperWidth) {
                    newW = wrapperWidth;
                    newH = newW / aspect;
                }
                canvas.style.height = newH + "px";
                canvas.style.width = newW + "px";
            } else {
                const fullW = wrapperWidth;
                const fullH = fullW / aspect;
                if (otherHeight + fullH > maxTotal) {
                    let newH = Math.max(60, maxTotal - otherHeight);
                    let newW = newH * aspect;
                    if (newW > wrapperWidth) {
                        newW = wrapperWidth;
                        newH = newW / aspect;
                    }
                    canvas.style.height = newH + "px";
                    canvas.style.width = newW + "px";
                } else {
                    canvas.style.width = "100%";
                    canvas.style.height = "auto";
                }
            }
        }

        window.addEventListener("resize", adjustCanvasSize);
        window.addEventListener("orientationchange", () => {
            setTimeout(adjustCanvasSize, 300);
        });

        // --- Socket setup ---

        socket = io();

        socket.on("roomsUpdate", rooms => {
            if (!joined) renderRoomsList(rooms);
        });

        joinForm.addEventListener("submit", e => {
            e.preventDefault();
            if (joined) return;
            const roomId = roomInput.value.trim() || "lobby";
            const name = nameInput.value.trim() || "";
            socket.emit("joinRoom", {
                roomId,
                name
            });

            // Try fullscreen as part of this explicit gesture (mobile)
            tryEnterFullscreen();
        });

        function renderRoomsList(rooms) {
            roomsListDiv.innerHTML = "";
            if (!rooms || rooms.length === 0) {
                roomsListDiv.innerHTML = "<div>No active rooms yet. Create one using the form.</div>";
                return;
            }
            rooms
                .sort((a, b) => a.roomId.localeCompare(b.roomId))
                .forEach(r => {
                    const btn = document.createElement("button");
                    const nameSpan = document.createElement("span");
                    nameSpan.className = "name";
                    nameSpan.textContent = r.roomId;
                    const countSpan = document.createElement("span");
                    countSpan.className = "count";
                    countSpan.textContent = `${r.count} in room`;
                    btn.appendChild(nameSpan);
                    btn.appendChild(countSpan);
                    btn.onclick = () => {
                        if (joined) return;
                        const name = nameInput.value.trim() || "";
                        socket.emit("joinRoom", {
                            roomId: r.roomId,
                            name
                        });

                        // Also attempt fullscreen on quick-join
                        tryEnterFullscreen();
                    };
                    roomsListDiv.appendChild(btn);
                });
        }

        socket.on("currentState", data => {
            joined = true;
            yourId = data.yourId;
            hostId = data.hostId || null;

            GRID_W = data.gridWidth || GRID_W;
            GRID_H = data.gridHeight || GRID_H;
            TILE_SIZE = canvas.width / GRID_W;
            JUMP_HEIGHT = TILE_SIZE * 0.35;

            walls = data.walls || [];
            reflectWalls = data.reflectWalls || [];
            spikes = data.spikes || [];
            cacti = (data.cacti || []).map(c => ({
                ...c
            }));

            for (const id in players) delete players[id];
            Object.assign(players, data.players || {});
            clearProjectilesLocal();

            gameState = data.state || "waiting";
            countdownStartTime = null;
            countdownDuration = 0;

            roomLabel.textContent = `Room: ${data.roomId}`;

            // Hide lobby UI in room
            if (joinCard) joinCard.style.display = "none";
            joinForm.style.display = "none";
            roomsContainer.style.display = "none";

            canvas.style.display = "block";
            cooldownWrapper.style.display = "flex";

            if (isTouchDevice) {
                infoDiv.style.display = "none";
                touchHint.style.display = "block";
            }

            renderScoreboard();
            renderStatus();
            updateAnnouncementInstant();
            renderHostControls();
            adjustCanvasSize();
        });

        socket.on("playerJoined", ({
            id,
            player
        }) => {
            players[id] = player;
            renderScoreboard();
            renderHostControls();
            adjustCanvasSize();
        });

        socket.on("playerLeft", ({
            id
        }) => {
            delete players[id];
            delete anims[id];
            renderScoreboard();
            renderHostControls();
            adjustCanvasSize();
        });

        socket.on("hostUpdate", ({
            hostId: newHost
        }) => {
            hostId = newHost || null;
            renderHostControls();
        });

        socket.on("playerMove", ({
            id,
            fromX,
            fromY,
            toX,
            toY,
            facing
        }) => {
            if (!players[id]) {
                players[id] = {
                    x: toX,
                    y: toY,
                    color: "#000",
                    name: `P-${id.slice(0, 4)}`,
                    hp: 5,
                    facing: facing || "down",
                    score: 0,
                    bulletsLoaded: 0
                };
            }
            if (facing) players[id].facing = facing;

            const existing = anims[id];
            if (existing && existing.active) {
                players[id].x = existing.toX;
                players[id].y = existing.toY;
                existing.active = false;
            }

            if (fromX === toX && fromY === toY) {
                anims[id] = {
                    fromX,
                    fromY,
                    toX,
                    toY,
                    startTime: performance.now(),
                    active: false
                };
                return;
            }

            anims[id] = {
                fromX,
                fromY,
                toX,
                toY,
                startTime: performance.now(),
                active: true
            };
        });

        socket.on("healthUpdate", ({
            hits
        }) => {
            hits.forEach(({
                id,
                hp
            }) => {
                if (players[id]) players[id].hp = hp;
            });
        });

        socket.on("ammoUpdate", ({
            id,
            bullets,
            lastReloadTime
        }) => {
            if (!players[id]) return;
            players[id].bulletsLoaded = bullets;
            if (typeof lastReloadTime === "number") {
                players[id].lastReloadTime = lastReloadTime;
            }
        });

        socket.on("ammoBulkUpdate", ({
            updates
        }) => {
            if (!updates) return;
            updates.forEach(({
                id,
                bullets,
                lastReloadTime
            }) => {
                if (!players[id]) return;
                players[id].bulletsLoaded = bullets;
                if (typeof lastReloadTime === "number") {
                    players[id].lastReloadTime = lastReloadTime;
                }
            });
        });

        socket.on("projectileSpawn", ({
            id,
            x,
            y,
            dx,
            dy
        }) => {
            projectiles[id] = {
                x,
                y,
                dx,
                dy
            };
        });

        socket.on("projectileUpdate", ({
            id,
            x,
            y,
            dx,
            dy
        }) => {
            if (!projectiles[id]) return;
            if (typeof x === "number") projectiles[id].x = x;
            if (typeof y === "number") projectiles[id].y = y;
            if (typeof dx === "number") projectiles[id].dx = dx;
            if (typeof dy === "number") projectiles[id].dy = dy;
        });

        socket.on("projectileDestroy", ({
            id,
            x,
            y
        }) => {
            const p = projectiles[id];
            if (p) {
                const px = typeof x === "number" ? x : p.x;
                const py = typeof y === "number" ? y : p.y;
                impactEffects.push({
                    x: px,
                    y: py,
                    startTime: performance.now(),
                    duration: 120
                });
                delete projectiles[id];
            }
        });

        socket.on("clearProjectiles", () => {
            clearProjectilesLocal();
        });

        socket.on("cactusUsed", ({
            x,
            y
        }) => {
            const c = cacti.find(c => c.x === x && c.y === y);
            if (c) c.used = true;
        });

        socket.on("roundState", ({
            state,
            countdown,
            players: serverPlayers,
            hostId: newHost,
            cacti: serverCacti
        }) => {
            gameState = state;
            if (typeof newHost !== "undefined") hostId = newHost;

            if (serverPlayers) {
                for (const id in players) delete players[id];
                Object.assign(players, serverPlayers);
            }
            if (serverCacti) {
                cacti = serverCacti.map(c => ({
                    ...c
                }));
            }

            clearProjectilesLocal();

            if (state === "waiting") {
                countdownStartTime = null;
                countdownDuration = 0;
            } else if (state === "countdown") {
                countdownDuration = countdown || 3000;
                countdownStartTime = performance.now();
            } else if (state === "playing") {
                countdownStartTime = null;
                countdownDuration = 0;
            }

            renderScoreboard();
            renderStatus();
            updateAnnouncementInstant();
            renderHostControls();
            adjustCanvasSize();
        });

        socket.on("roundOver", ({
            winnerId,
            scores,
            hostId: newHost,
            cacti: serverCacti
        }) => {
            gameState = "round_over";
            if (typeof newHost !== "undefined") hostId = newHost;
            if (serverCacti) {
                cacti = serverCacti.map(c => ({
                    ...c
                }));
            }

            clearProjectilesLocal();

            if (scores) {
                Object.entries(scores).forEach(([id, score]) => {
                    if (!players[id]) players[id] = {};
                    players[id].score = score;
                });
            }
            renderScoreboard();

            let msg;
            if (winnerId && players[winnerId]) {
                const name = players[winnerId].name || "Player";
                msg = `${name} wins this round!`;
            } else {
                msg = "Round over!";
            }

            announcementDiv.textContent = msg;
            announcementDiv.classList.add("visible");
            statusMessageDiv.textContent = `${msg} Host can start the next round.`;

            renderHostControls();
            adjustCanvasSize();
        });

        // --- Keyboard input ---

        window.addEventListener("keydown", e => {
            if (!joined || !socket) return;
            if (gameState !== "playing") return;

            const me = players[yourId];
            if (!me || me.hp <= 0) return;

            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
                e.preventDefault();
                const dir =
                    e.key === "ArrowUp" ? "up" :
                    e.key === "ArrowDown" ? "down" :
                    e.key === "ArrowLeft" ? "left" : "right";
                socket.emit("move", {
                    direction: dir
                });
                return;
            }

            if (e.code === "Space") {
                e.preventDefault();
                const bullets = me.bulletsLoaded ?? 0;
                if (bullets > 0) socket.emit("shoot");
            }
        });

        // --- Touch input (also used to trigger fullscreen once in room) ---

        if (isTouchDevice) {
            document.addEventListener("touchstart", handleTouchStart, {
                passive: false
            });
        }

        function handleTouchStart(e) {
            if (joined && !hasRequestedFullscreen) {
                // First in-room touch: try to go fullscreen
                tryEnterFullscreen();
                adjustCanvasSize();
            }

            if (!joined || !socket) return;
            if (gameState !== "playing") return;

            const me = players[yourId];
            if (!me || me.hp <= 0) return;

            const touch = e.touches[0];
            if (!touch) return;

            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const x = touch.clientX;
            const y = touch.clientY;

            const marginX = vw * 0.22;
            const marginY = vh * 0.22;

            const inTopBand = y < marginY;
            const inBottomBand = y > vh - marginY;
            const inMiddleY = y >= marginY && y <= vh - marginY;
            const inLeftBand = x < marginX;
            const inRightBand = x > vw - marginX;

            let action, dir;

            if (inTopBand) {
                action = "move";
                dir = "up";
            } else if (inBottomBand) {
                action = "move";
                dir = "down";
            } else if (inMiddleY && inLeftBand) {
                action = "move";
                dir = "left";
            } else if (inMiddleY && inRightBand) {
                action = "move";
                dir = "right";
            } else {
                action = "shoot";
            }

            if (action === "move") {
                e.preventDefault();
                socket.emit("move", {
                    direction: dir
                });
                showTouchFeedback("move", dir, marginX, marginY);
            } else if (action === "shoot") {
                e.preventDefault();
                const bullets = me.bulletsLoaded ?? 0;
                if (bullets > 0) socket.emit("shoot");
                showTouchFeedback("shoot", null, marginX, marginY);
            }
        }

        // --- Host button (also a nice place to poke fullscreen) ---

        startButton.addEventListener("click", () => {
            if (!socket) return;
            socket.emit("startRound");
            tryEnterFullscreen();
            adjustCanvasSize();
        });

        // --- Helpers ---

        function clearProjectilesLocal() {
            for (const id in projectiles) delete projectiles[id];
            impactEffects.length = 0;
        }

        function renderScoreboard() {
            const ids = Object.keys(players);
            if (!ids.length) {
                scoreboardDiv.textContent = "";
                return;
            }
            const parts = ids.map(id => {
                const p = players[id];
                if (!p) return "";
                const name = p.name || id.slice(0, 4);
                const score = p.score || 0;
                return `${name}: ${score}`;
            }).filter(Boolean);
            scoreboardDiv.textContent = parts.length ?
                "Score • " + parts.join(" | ") :
                "";
        }

        function renderStatus() {
            if (gameState === "waiting") {
                statusMessageDiv.textContent = "Waiting. Host can start when ready (≥2 players).";
            } else if (gameState === "countdown") {
                statusMessageDiv.textContent = "Round starting...";
            } else if (gameState === "playing") {
                statusMessageDiv.textContent = "Fight!";
            }
        }

        function renderHostControls() {
            if (!joined) {
                startButton.style.display = "none";
                return;
            }
            const isHost = yourId && hostId && yourId === hostId;
            if (!isHost) {
                startButton.style.display = "none";
                return;
            }
            const playersCount = Object.keys(players).length;
            if ((gameState === "waiting" || gameState === "round_over") && playersCount >= 2) {
                startButton.style.display = "inline-flex";
            } else {
                startButton.style.display = "none";
            }
        }

        function updateAnnouncementInstant() {
            if (gameState === "waiting") {
                announcementDiv.textContent = "Waiting for host to start (≥2 players)...";
                announcementDiv.classList.add("visible");
            } else if (gameState === "playing") {
                announcementDiv.textContent = "";
                announcementDiv.classList.remove("visible");
            }
        }

        function updateAnnouncementDuringCountdown(now) {
            if (gameState !== "countdown" || countdownStartTime === null) return;
            const elapsed = now - countdownStartTime;
            let remaining = countdownDuration - elapsed;
            if (remaining < 0) remaining = 0;
            const seconds = Math.max(1, Math.ceil(remaining / 1000));
            announcementDiv.textContent = `Round starts in ${seconds}`;
            announcementDiv.classList.add("visible");
        }

        function getBulletFillRatio(now) {
            const me = players[yourId];
            if (!me) return 0;
            const base = Math.max(0, Math.min(MAX_BULLETS, me.bulletsLoaded || 0));
            let ratio = base / MAX_BULLETS;

            if (
                base < MAX_BULLETS &&
                typeof me.lastReloadTime === "number" &&
                (gameState === "playing" || gameState === "countdown")
            ) {
                const elapsed = now - me.lastReloadTime;
                const extra = Math.max(0, Math.min(1, elapsed / BULLET_RELOAD_MS));
                ratio += extra / MAX_BULLETS;
            }
            return Math.max(0, Math.min(1, ratio));
        }

        function updateBulletUI(now = performance.now()) {
            if (!joined) return;
            const me = players[yourId];
            const bullets = me && typeof me.bulletsLoaded === "number" ?
                Math.max(0, Math.min(MAX_BULLETS, me.bulletsLoaded)) :
                0;
            const ratio = getBulletFillRatio(now);
            cooldownBarFill.style.width = `${ratio * 100}%`;
            cooldownText.textContent = `${bullets}/${MAX_BULLETS}`;
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#e5e7eb";
            for (let x = 0; x <= GRID_W; x++) {
                const px = x * TILE_SIZE;
                ctx.beginPath();
                ctx.moveTo(px, 0);
                ctx.lineTo(px, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= GRID_H; y++) {
                const py = y * TILE_SIZE;
                ctx.beginPath();
                ctx.moveTo(0, py);
                ctx.lineTo(canvas.width, py);
                ctx.stroke();
            }
        }

        function drawTerrain() {
            ctx.fillStyle = "#000";
            walls.forEach(w => {
                ctx.fillRect(w.x * TILE_SIZE, w.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            });

            reflectWalls.forEach(w => {
                const x = w.x * TILE_SIZE;
                const y = w.y * TILE_SIZE;
                ctx.fillStyle = "#000";
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                ctx.lineWidth = 4;
                ctx.strokeStyle = "#ffd700";
                ctx.strokeRect(x + 1.5, y + 1.5, TILE_SIZE - 3, TILE_SIZE - 3);
            });

            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3;
            spikes.forEach(s => {
                const x = s.x * TILE_SIZE;
                const y = s.y * TILE_SIZE;
                ctx.beginPath();
                ctx.moveTo(x + TILE_SIZE * 0.2, y + TILE_SIZE * 0.2);
                ctx.lineTo(x + TILE_SIZE * 0.8, y + TILE_SIZE * 0.8);
                ctx.moveTo(x + TILE_SIZE * 0.8, y + TILE_SIZE * 0.2);
                ctx.lineTo(x + TILE_SIZE * 0.2, y + TILE_SIZE * 0.8);
                ctx.stroke();
            });

            cacti.forEach(c => {
                const x = c.x * TILE_SIZE;
                const y = c.y * TILE_SIZE;
                const pad = TILE_SIZE * 0.14;
                const bodyX = x + pad;
                const bodyY = y + pad;
                const bodyW = TILE_SIZE - pad * 2;
                const bodyH = TILE_SIZE - pad * 2;

                ctx.fillStyle = "#27ae60";
                ctx.fillRect(bodyX, bodyY, bodyW, bodyH);

                if (!c.used) {
                    ctx.fillStyle = "#000";
                    const bLen = TILE_SIZE * 0.46;
                    const bThick = TILE_SIZE * 0.12;
                    ctx.fillRect(x + TILE_SIZE / 2 - bThick / 2, bodyY - bLen * 0.35, bThick, bLen);
                    ctx.fillRect(x + TILE_SIZE / 2 - bThick / 2, bodyY + bodyH - bLen * 0.65, bThick, bLen);
                    ctx.fillRect(bodyX - bLen * 0.35, y + TILE_SIZE / 2 - bThick / 2, bLen, bThick);
                    ctx.fillRect(bodyX + bodyW - bLen * 0.65, y + TILE_SIZE / 2 - bThick / 2, bLen, bThick);
                }
            });
        }

        function drawTrianglePlayer(id, gridX, gridY, jumpOffset = 0) {
            const p = players[id];
            if (!p) return;

            const padding = TILE_SIZE * 0.12;
            const baseX = gridX * TILE_SIZE;
            const baseY = gridY * TILE_SIZE + jumpOffset;

            if (id === yourId) {
                ctx.fillStyle = "rgba(255, 255, 0, 0.16)";
                ctx.fillRect(baseX, gridY * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }

            const px = baseX + padding;
            const py = baseY + padding;
            const size = TILE_SIZE - padding * 2;
            const cx = px + size / 2;
            const cy = py + size / 2;

            let tip, back1, back2;
            switch (p.facing || "down") {
                case "up":
                    tip = {
                        x: cx,
                        y: py
                    };
                    back1 = {
                        x: px,
                        y: py + size
                    };
                    back2 = {
                        x: px + size,
                        y: py + size
                    };
                    break;
                case "down":
                    tip = {
                        x: cx,
                        y: py + size
                    };
                    back1 = {
                        x: px,
                        y: py
                    };
                    back2 = {
                        x: px + size,
                        y: py
                    };
                    break;
                case "left":
                    tip = {
                        x: px,
                        y: cy
                    };
                    back1 = {
                        x: px + size,
                        y: py
                    };
                    back2 = {
                        x: px + size,
                        y: py + size
                    };
                    break;
                case "right":
                default:
                    tip = {
                        x: px + size,
                        y: cy
                    };
                    back1 = {
                        x: px,
                        y: py
                    };
                    back2 = {
                        x: px,
                        y: py + size
                    };
                    break;
            }

            // Shadow
            ctx.save();
            ctx.fillStyle = "rgba(0,0,0,0.18)";
            ctx.beginPath();
            ctx.moveTo(tip.x + 2, tip.y + 2);
            ctx.lineTo(back1.x + 2, back1.y + 2);
            ctx.lineTo(back2.x + 2, back2.y + 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            const radius = TILE_SIZE * 0.18;
            ctx.beginPath();
            ctx.moveTo(tip.x, tip.y);
            ctx.lineTo(back1.x, back1.y);
            ctx.arcTo(back1.x, back1.y, back2.x, back2.y, radius);
            ctx.lineTo(back2.x, back2.y);
            ctx.arcTo(back2.x, back2.y, tip.x, tip.y, radius);
            ctx.lineTo(tip.x, tip.y);
            ctx.closePath();

            ctx.fillStyle = p.hp > 0 ? (p.color || "#1e90ff") : "#7f8c8d";
            ctx.fill();

            if (id === yourId) {
                ctx.lineWidth = 3;
                ctx.strokeStyle = "#000";
                ctx.stroke();
            }

            // HP bar segments
            const maxHp = 5;
            const hp = Math.max(0, Math.min(maxHp, p.hp || 0));
            const segments = 5;
            const gap = 1;
            const barWidth = size;
            const barHeight = 3;
            const barX = px;
            const barY = py + size + 2;
            const segWidth = (barWidth - gap * (segments - 1)) / segments;

            for (let i = 0; i < segments; i++) {
                const sx = barX + i * (segWidth + gap);
                ctx.fillStyle = "#e5e7eb";
                ctx.fillRect(sx, barY, segWidth, barHeight);
                if (i < hp) {
                    ctx.fillStyle = "#22c55e";
                    ctx.fillRect(sx, barY, segWidth, barHeight);
                }
            }

            if (p.name) {
                ctx.font = "10px sans-serif";
                ctx.fillStyle = "#111827";
                ctx.textAlign = "center";
                ctx.fillText(p.name, cx, py - 3);
            }
        }

        function drawProjectiles(now) {
            const groups = {};
            for (const id in projectiles) {
                const p = projectiles[id];
                const key = `${p.x},${p.y},${p.dx},${p.dy}`;
                if (!groups[key]) groups[key] = {
                    x: p.x,
                    y: p.y,
                    dx: p.dx,
                    dy: p.dy,
                    count: 0
                };
                groups[key].count++;
            }

            ctx.save();
            ctx.fillStyle = "#000";
            Object.values(groups).forEach(g => {
                const {
                    x,
                    y,
                    dx,
                    dy,
                    count
                } = g;
                const cx = x * TILE_SIZE + TILE_SIZE / 2;
                const cy = y * TILE_SIZE + TILE_SIZE / 2;
                const n = Math.max(1, count);

                if (dx !== 0) {
                    const w = TILE_SIZE * 0.6;
                    const h = TILE_SIZE * 0.14;
                    const gap = TILE_SIZE * 0.05;
                    const totalH = n * h + (n - 1) * gap;
                    let sy = cy - totalH / 2;
                    for (let i = 0; i < n; i++) {
                        ctx.fillRect(cx - w / 2, sy, w, h);
                        sy += h + gap;
                    }
                } else if (dy !== 0) {
                    const w = TILE_SIZE * 0.14;
                    const h = TILE_SIZE * 0.6;
                    const gap = TILE_SIZE * 0.05;
                    const totalW = n * w + (n - 1) * gap;
                    let sx = cx - totalW / 2;
                    for (let i = 0; i < n; i++) {
                        ctx.fillRect(sx, cy - h / 2, w, h);
                        sx += w + gap;
                    }
                }
            });
            ctx.restore();

            const keep = [];
            impactEffects.forEach(effect => {
                const t = now - effect.startTime;
                if (t < 0 || t > effect.duration) return;
                const alpha = 1 - t / effect.duration;
                const cx = effect.x * TILE_SIZE + TILE_SIZE / 2;
                const cy = effect.y * TILE_SIZE + TILE_SIZE / 2;
                const size = TILE_SIZE * 0.4;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = "#ef4444";
                ctx.fillRect(cx - size / 2, cy - size / 2, size, size);
                ctx.restore();
                keep.push(effect);
            });
            impactEffects.length = 0;
            impactEffects.push(...keep);
        }

        function gameLoop(ts) {
            if (!joined) {
                requestAnimationFrame(gameLoop);
                return;
            }
            const now = ts || performance.now();

            drawGrid();
            drawTerrain();

            for (const id in players) {
                const p = players[id];
                const anim = anims[id];
                if (anim && anim.active) {
                    const elapsed = now - anim.startTime;
                    let t = elapsed / MOVE_DURATION;
                    if (t >= 1) {
                        t = 1;
                        anim.active = false;
                        p.x = anim.toX;
                        p.y = anim.toY;
                        drawTrianglePlayer(id, p.x, p.y, 0);
                    } else {
                        const gx = anim.fromX + (anim.toX - anim.fromX) * t;
                        const gy = anim.fromY + (anim.toY - anim.fromY) * t;
                        const dx = anim.toX - anim.fromX;
                        const dy = anim.toY - anim.fromY;
                        let jumpOffset = 0;
                        if (dy !== 0 && dx === 0) {
                            jumpOffset = -4 * JUMP_HEIGHT * t * (1 - t);
                        }
                        drawTrianglePlayer(id, gx, gy, jumpOffset);
                    }
                } else {
                    drawTrianglePlayer(id, p.x, p.y, 0);
                }
            }

            drawProjectiles(now);
            updateBulletUI(now);

            if (gameState === "countdown") {
                updateAnnouncementDuringCountdown(now);
            } else if (gameState === "playing") {
                if (announcementDiv.textContent.startsWith("Round starts in")) {
                    announcementDiv.textContent = "";
                    announcementDiv.classList.remove("visible");
                }
            } else if (gameState === "waiting") {
                announcementDiv.textContent = "Waiting for host to start (≥2 players)...";
                announcementDiv.classList.add("visible");
            }

            renderHostControls();
            requestAnimationFrame(gameLoop);
        }

        requestAnimationFrame(gameLoop);
    </script>
</body>

</html>